// TCG TPM2 Structures interface code
// Autogenerated with gen-tpm2-cmd-interface version 0.1.0

#![allow(clippy::needless_lifetimes)]
#![allow(clippy::identity_op)]

extern crate alloc;
use alloc::{boxed, vec};

#[allow(unused_imports)]
use vec::Vec;
#[allow(unused_imports)]
use boxed::Box;
#[allow(unused_imports)]
use core::cmp;
use core::convert;
use core::mem;
use core::ops;
#[allow(unused_imports)]
use core::ptr;

#[derive(Clone, Copy, Debug)]
pub enum TpmErr {
    Rc(u32),
    InternalErr,
}

#[allow(unused)]
fn copy_vec_from_slice<T: Copy>(slice: &[T]) -> Result<Vec<T>, TpmErr> {
    let mut v = Vec::new();
    v.try_reserve_exact(slice.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
    v.extend_from_slice(slice);
    Ok(v)
}

#[derive(Clone, Debug)]
pub enum TpmBuffer<'a> {
    Borrowed(&'a [u8]),
    Owned(Vec<u8>),
}

impl<'a> TpmBuffer<'a> {
    pub fn into_owned(mut self) -> Result<TpmBuffer<'static>, TpmErr> {
        let o = match &mut self {
            Self::Borrowed(b) => copy_vec_from_slice(b)?,
            Self::Owned(o) => {
                #[allow(clippy::mem_replace_with_default)]
                mem::replace(o, Vec::new())
            },
        };
        Ok(TpmBuffer::<'static>::Owned(o))
    }
}

#[cfg(feature = "zeroize")]
impl<'a> Drop for TpmBuffer<'a> {
    fn drop(&mut self) {
        match self {
            Self::Borrowed(_) => (),
            Self::Owned(o) => {
                #[cfg(feature = "zeroize")]
                <[u8] as zeroize::Zeroize>::zeroize(o.as_mut_slice());
            }
        }
    }
}

impl<'a> ops::Deref for TpmBuffer<'a> {
    type Target = [u8];

    fn deref(&self) -> &Self::Target {
        match self {
            Self::Borrowed(b) => b,
            Self::Owned(o) => o,
        }
    }
}

impl<'a> convert::From<&'a [u8]> for TpmBuffer<'a> {
    fn from(value: &'a [u8]) -> Self {
        Self::Borrowed(value)
    }
}

impl<'a> PartialEq for TpmBuffer<'a> {
    fn eq(&self, other: &Self) -> bool {
        <Self as ops::Deref>::deref(self) == <Self as ops::Deref>::deref(other)
    }
}

#[allow(unused)]
fn split_slice_at<T>(s: &[T], mid: usize) -> Result<(&[T], &[T]), TpmErr> {
    if s.len() < mid {
        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
    }
    Ok(s.split_at(mid))
}

#[allow(unused)]
fn split_slice_at_mut<T>(s: &mut [T], mid: usize) -> Result<(&mut [T], &mut [T]), TpmErr> {
    if s.len() < mid {
        return Err(TpmErr::InternalErr);
    }
    Ok(s.split_at_mut(mid))
}

#[allow(unused)]
pub fn unmarshal_u8(buf: &[u8]) -> Result<(&[u8], u8), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<u8>())?;
    let consumed = <&[u8; mem::size_of::<u8>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = u8::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_i8(buf: &[u8]) -> Result<(&[u8], i8), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<i8>())?;
    let consumed = <&[u8; mem::size_of::<i8>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = i8::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_u16(buf: &[u8]) -> Result<(&[u8], u16), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<u16>())?;
    let consumed = <&[u8; mem::size_of::<u16>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = u16::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_i16(buf: &[u8]) -> Result<(&[u8], i16), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<i16>())?;
    let consumed = <&[u8; mem::size_of::<i16>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = i16::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_u32(buf: &[u8]) -> Result<(&[u8], u32), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<u32>())?;
    let consumed = <&[u8; mem::size_of::<u32>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = u32::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_i32(buf: &[u8]) -> Result<(&[u8], i32), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<i32>())?;
    let consumed = <&[u8; mem::size_of::<i32>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = i32::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_u64(buf: &[u8]) -> Result<(&[u8], u64), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<u64>())?;
    let consumed = <&[u8; mem::size_of::<u64>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = u64::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_i64(buf: &[u8]) -> Result<(&[u8], i64), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<i64>())?;
    let consumed = <&[u8; mem::size_of::<i64>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = i64::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn marshal_u8(buf: &mut [u8], value: u8) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<u8>())?;
    let produced = <&mut [u8; mem::size_of::<u8>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_i8(buf: &mut [u8], value: i8) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<i8>())?;
    let produced = <&mut [u8; mem::size_of::<i8>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_u16(buf: &mut [u8], value: u16) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<u16>())?;
    let produced = <&mut [u8; mem::size_of::<u16>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_i16(buf: &mut [u8], value: i16) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<i16>())?;
    let produced = <&mut [u8; mem::size_of::<i16>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_u32(buf: &mut [u8], value: u32) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<u32>())?;
    let produced = <&mut [u8; mem::size_of::<u32>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_i32(buf: &mut [u8], value: i32) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<i32>())?;
    let produced = <&mut [u8; mem::size_of::<i32>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_u64(buf: &mut [u8], value: u64) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<u64>())?;
    let produced = <&mut [u8; mem::size_of::<u64>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_i64(buf: &mut [u8], value: i64) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<i64>())?;
    let produced = <&mut [u8; mem::size_of::<i64>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
fn marshal_bytes<'a>(buf: &'a mut [u8], src: &[u8]) -> Result<&'a mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, src.len())?;
    produced.copy_from_slice(src);
    Ok(buf)
}

// TCG Algorithm Registry, page 11, table 3, TPM_ALG_ID constants
#[cfg(any(feature = "aes", feature = "camellia", feature = "cbc", feature = "cfb", feature = "ctr", feature = "ecb", feature = "ofb", feature = "sha1", feature = "sha256", feature = "sha384", feature = "sha3_256", feature = "sha3_384", feature = "sha3_512", feature = "sha512", feature = "sm3_256", feature = "sm4", feature = "tdes"))]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
enum TpmAlgId {
    #[cfg(feature = "tdes")]
    Tdes = 0x3u16,
    #[cfg(feature = "sha1")]
    Sha1 = 0x4u16,
    #[cfg(feature = "aes")]
    Aes = 0x6u16,
    #[cfg(feature = "sha256")]
    Sha256 = 0xbu16,
    #[cfg(feature = "sha384")]
    Sha384 = 0xcu16,
    #[cfg(feature = "sha512")]
    Sha512 = 0xdu16,
    #[cfg(feature = "sm3_256")]
    Sm3_256 = 0x12u16,
    #[cfg(feature = "sm4")]
    Sm4 = 0x13u16,
    #[cfg(feature = "camellia")]
    Camellia = 0x26u16,
    #[cfg(feature = "sha3_256")]
    Sha3_256 = 0x27u16,
    #[cfg(feature = "sha3_384")]
    Sha3_384 = 0x28u16,
    #[cfg(feature = "sha3_512")]
    Sha3_512 = 0x29u16,
    #[cfg(feature = "ctr")]
    Ctr = 0x40u16,
    #[cfg(feature = "ofb")]
    Ofb = 0x41u16,
    #[cfg(feature = "cbc")]
    Cbc = 0x42u16,
    #[cfg(feature = "cfb")]
    Cfb = 0x43u16,
    #[cfg(feature = "ecb")]
    Ecb = 0x44u16,
}

// TCG Algorithm Registry, page 15, table 4, TPM_ECC_CURVE constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmEccCurve {
    None = 0x0u16,
    #[cfg(feature = "ecc_nist_p192")]
    NistP192 = 0x1u16,
    #[cfg(feature = "ecc_nist_p224")]
    NistP224 = 0x2u16,
    #[cfg(feature = "ecc_nist_p256")]
    NistP256 = 0x3u16,
    #[cfg(feature = "ecc_nist_p384")]
    NistP384 = 0x4u16,
    #[cfg(feature = "ecc_nist_p521")]
    NistP521 = 0x5u16,
    #[cfg(feature = "ecc_bn_p256")]
    BnP256 = 0x10u16,
    #[cfg(feature = "ecc_bn_p638")]
    BnP638 = 0x11u16,
    #[cfg(feature = "ecc_sm2_p256")]
    Sm2P256 = 0x20u16,
    #[cfg(feature = "ecc_bp_p256_r1")]
    BpP256R1 = 0x30u16,
    #[cfg(feature = "ecc_bp_p384_r1")]
    BpP384R1 = 0x31u16,
    #[cfg(feature = "ecc_bp_p512_r1")]
    BpP512R1 = 0x32u16,
    #[cfg(feature = "ecc_curve_25519")]
    Curve25519 = 0x40u16,
    #[cfg(feature = "ecc_curve_448")]
    Curve448 = 0x41u16,
}

impl convert::TryFrom<u16> for TpmEccCurve {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::None as u16 => Self::None,
            #[cfg(feature = "ecc_nist_p192")]
            value if value == Self::NistP192 as u16 => Self::NistP192,
            #[cfg(feature = "ecc_nist_p224")]
            value if value == Self::NistP224 as u16 => Self::NistP224,
            #[cfg(feature = "ecc_nist_p256")]
            value if value == Self::NistP256 as u16 => Self::NistP256,
            #[cfg(feature = "ecc_nist_p384")]
            value if value == Self::NistP384 as u16 => Self::NistP384,
            #[cfg(feature = "ecc_nist_p521")]
            value if value == Self::NistP521 as u16 => Self::NistP521,
            #[cfg(feature = "ecc_bn_p256")]
            value if value == Self::BnP256 as u16 => Self::BnP256,
            #[cfg(feature = "ecc_bn_p638")]
            value if value == Self::BnP638 as u16 => Self::BnP638,
            #[cfg(feature = "ecc_sm2_p256")]
            value if value == Self::Sm2P256 as u16 => Self::Sm2P256,
            #[cfg(feature = "ecc_bp_p256_r1")]
            value if value == Self::BpP256R1 as u16 => Self::BpP256R1,
            #[cfg(feature = "ecc_bp_p384_r1")]
            value if value == Self::BpP384R1 as u16 => Self::BpP384R1,
            #[cfg(feature = "ecc_bp_p512_r1")]
            value if value == Self::BpP512R1 as u16 => Self::BpP512R1,
            #[cfg(feature = "ecc_curve_25519")]
            value if value == Self::Curve25519 as u16 => Self::Curve25519,
            #[cfg(feature = "ecc_curve_448")]
            value if value == Self::Curve448 as u16 => Self::Curve448,
            _ => {
                return Err(TpmErr::Rc(TpmRc::CURVE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Part 2 -- Structures, page 54, table 16, TPM_RC constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmRc {
}

impl TpmRc {
    pub const SUCCESS: u32 = 0x0u32;
    pub const BAD_TAG: u32 = 0x1eu32;
    pub const VER1: u32 = 0x100u32;
    pub const INITIALIZE: u32 = Self::VER1 + 0x0u32;
    pub const FAILURE: u32 = Self::VER1 + 0x1u32;
    pub const SEQUENCE: u32 = Self::VER1 + 0x3u32;
    pub const PRIVATE: u32 = Self::VER1 + 0xbu32;
    pub const HMAC: u32 = Self::VER1 + 0x19u32;
    pub const DISABLED: u32 = Self::VER1 + 0x20u32;
    pub const EXCLUSIVE: u32 = Self::VER1 + 0x21u32;
    pub const AUTH_TYPE: u32 = Self::VER1 + 0x24u32;
    pub const AUTH_MISSING: u32 = Self::VER1 + 0x25u32;
    pub const POLICY: u32 = Self::VER1 + 0x26u32;
    pub const PCR: u32 = Self::VER1 + 0x27u32;
    pub const PCR_CHANGED: u32 = Self::VER1 + 0x28u32;
    pub const UPGRADE: u32 = Self::VER1 + 0x2du32;
    pub const TOO_MANY_CONTEXTS: u32 = Self::VER1 + 0x2eu32;
    pub const AUTH_UNAVAILABLE: u32 = Self::VER1 + 0x2fu32;
    pub const REBOOT: u32 = Self::VER1 + 0x30u32;
    pub const UNBALANCED: u32 = Self::VER1 + 0x31u32;
    pub const COMMAND_SIZE: u32 = Self::VER1 + 0x42u32;
    pub const COMMAND_CODE: u32 = Self::VER1 + 0x43u32;
    pub const AUTHSIZE: u32 = Self::VER1 + 0x44u32;
    pub const AUTH_CONTEXT: u32 = Self::VER1 + 0x45u32;
    pub const NV_RANGE: u32 = Self::VER1 + 0x46u32;
    pub const NV_SIZE: u32 = Self::VER1 + 0x47u32;
    pub const NV_LOCKED: u32 = Self::VER1 + 0x48u32;
    pub const NV_AUTHORIZATION: u32 = Self::VER1 + 0x49u32;
    pub const NV_UNINITIALIZED: u32 = Self::VER1 + 0x4au32;
    pub const NV_SPACE: u32 = Self::VER1 + 0x4bu32;
    pub const NV_DEFINED: u32 = Self::VER1 + 0x4cu32;
    pub const BAD_CONTEXT: u32 = Self::VER1 + 0x50u32;
    pub const CPHASH: u32 = Self::VER1 + 0x51u32;
    pub const PARENT: u32 = Self::VER1 + 0x52u32;
    pub const NEEDS_TEST: u32 = Self::VER1 + 0x53u32;
    pub const NO_RESULT: u32 = Self::VER1 + 0x54u32;
    pub const SENSITIVE: u32 = Self::VER1 + 0x55u32;
    pub const MAX_FM0: u32 = Self::VER1 + 0x7fu32;
    pub const FMT1: u32 = 0x80u32;
    pub const ASYMMETRIC: u32 = Self::FMT1 + 0x1u32;
    pub const ATTRIBUTES: u32 = Self::FMT1 + 0x2u32;
    pub const HASH: u32 = Self::FMT1 + 0x3u32;
    pub const VALUE: u32 = Self::FMT1 + 0x4u32;
    pub const HIERARCHY: u32 = Self::FMT1 + 0x5u32;
    pub const KEY_SIZE: u32 = Self::FMT1 + 0x7u32;
    pub const MGF: u32 = Self::FMT1 + 0x8u32;
    pub const MODE: u32 = Self::FMT1 + 0x9u32;
    pub const TYPE: u32 = Self::FMT1 + 0xau32;
    pub const HANDLE: u32 = Self::FMT1 + 0xbu32;
    pub const KDF: u32 = Self::FMT1 + 0xcu32;
    pub const RANGE: u32 = Self::FMT1 + 0xdu32;
    pub const AUTH_FAIL: u32 = Self::FMT1 + 0xeu32;
    pub const NONCE: u32 = Self::FMT1 + 0xfu32;
    pub const PP: u32 = Self::FMT1 + 0x10u32;
    pub const SCHEME: u32 = Self::FMT1 + 0x12u32;
    pub const SIZE: u32 = Self::FMT1 + 0x15u32;
    pub const SYMMETRIC: u32 = Self::FMT1 + 0x16u32;
    pub const TAG: u32 = Self::FMT1 + 0x17u32;
    pub const SELECTOR: u32 = Self::FMT1 + 0x18u32;
    pub const INSUFFICIENT: u32 = Self::FMT1 + 0x1au32;
    pub const SIGNATURE: u32 = Self::FMT1 + 0x1bu32;
    pub const KEY: u32 = Self::FMT1 + 0x1cu32;
    pub const POLICY_FAIL: u32 = Self::FMT1 + 0x1du32;
    pub const INTEGRITY: u32 = Self::FMT1 + 0x1fu32;
    pub const TICKET: u32 = Self::FMT1 + 0x20u32;
    pub const RESERVED_BITS: u32 = Self::FMT1 + 0x21u32;
    pub const BAD_AUTH: u32 = Self::FMT1 + 0x22u32;
    pub const EXPIRED: u32 = Self::FMT1 + 0x23u32;
    pub const POLICY_CC: u32 = Self::FMT1 + 0x24u32;
    pub const BINDING: u32 = Self::FMT1 + 0x25u32;
    pub const CURVE: u32 = Self::FMT1 + 0x26u32;
    pub const ECC_POINT: u32 = Self::FMT1 + 0x27u32;
    pub const WARN: u32 = 0x900u32;
    pub const CONTEXT_GAP: u32 = Self::WARN + 0x1u32;
    pub const OBJECT_MEMORY: u32 = Self::WARN + 0x2u32;
    pub const SESSION_MEMORY: u32 = Self::WARN + 0x3u32;
    pub const MEMORY: u32 = Self::WARN + 0x4u32;
    pub const SESSION_HANDLES: u32 = Self::WARN + 0x5u32;
    pub const OBJECT_HANDLES: u32 = Self::WARN + 0x6u32;
    pub const LOCALITY: u32 = Self::WARN + 0x7u32;
    pub const YIELDED: u32 = Self::WARN + 0x8u32;
    pub const CANCELED: u32 = Self::WARN + 0x9u32;
    pub const TESTING: u32 = Self::WARN + 0xau32;
    pub const REFERENCE_H0: u32 = Self::WARN + 0x10u32;
    pub const REFERENCE_H1: u32 = Self::WARN + 0x11u32;
    pub const REFERENCE_H2: u32 = Self::WARN + 0x12u32;
    pub const REFERENCE_H3: u32 = Self::WARN + 0x13u32;
    pub const REFERENCE_H4: u32 = Self::WARN + 0x14u32;
    pub const REFERENCE_H5: u32 = Self::WARN + 0x15u32;
    pub const REFERENCE_H6: u32 = Self::WARN + 0x16u32;
    pub const REFERENCE_S0: u32 = Self::WARN + 0x18u32;
    pub const REFERENCE_S1: u32 = Self::WARN + 0x19u32;
    pub const REFERENCE_S2: u32 = Self::WARN + 0x1au32;
    pub const REFERENCE_S3: u32 = Self::WARN + 0x1bu32;
    pub const REFERENCE_S4: u32 = Self::WARN + 0x1cu32;
    pub const REFERENCE_S5: u32 = Self::WARN + 0x1du32;
    pub const REFERENCE_S6: u32 = Self::WARN + 0x1eu32;
    pub const NV_RATE: u32 = Self::WARN + 0x20u32;
    pub const LOCKOUT: u32 = Self::WARN + 0x21u32;
    pub const RETRY: u32 = Self::WARN + 0x22u32;
    pub const NV_UNAVAILABLE: u32 = Self::WARN + 0x23u32;
    pub const NOT_USED: u32 = Self::WARN + 0x7fu32;
    pub const RC_H: u32 = 0x0u32;
    pub const RC_P: u32 = 0x40u32;
    pub const RC_S: u32 = 0x800u32;
    pub const RC_1: u32 = 0x100u32;
    pub const RC_2: u32 = 0x200u32;
    pub const RC_3: u32 = 0x300u32;
    pub const RC_4: u32 = 0x400u32;
    pub const RC_5: u32 = 0x500u32;
    pub const RC_6: u32 = 0x600u32;
    pub const RC_7: u32 = 0x700u32;
    pub const RC_8: u32 = 0x800u32;
    pub const RC_9: u32 = 0x900u32;
    pub const RC_A: u32 = 0xa00u32;
    pub const RC_B: u32 = 0xb00u32;
    pub const RC_C: u32 = 0xc00u32;
    pub const RC_D: u32 = 0xd00u32;
    pub const RC_E: u32 = 0xe00u32;
    pub const RC_F: u32 = 0xf00u32;
    pub const N_MASK: u32 = 0xf00u32;
}

// TCG TPM2 Library, Part 2 -- Structures, page 107, table 65, TPMI_ALG_HASH type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgHash {
    #[cfg(feature = "sha1")]
    Sha1 = TpmAlgId::Sha1 as u16,
    #[cfg(feature = "sha256")]
    Sha256 = TpmAlgId::Sha256 as u16,
    #[cfg(feature = "sha384")]
    Sha384 = TpmAlgId::Sha384 as u16,
    #[cfg(feature = "sha512")]
    Sha512 = TpmAlgId::Sha512 as u16,
    #[cfg(feature = "sm3_256")]
    Sm3_256 = TpmAlgId::Sm3_256 as u16,
    #[cfg(feature = "sha3_256")]
    Sha3_256 = TpmAlgId::Sha3_256 as u16,
    #[cfg(feature = "sha3_384")]
    Sha3_384 = TpmAlgId::Sha3_384 as u16,
    #[cfg(feature = "sha3_512")]
    Sha3_512 = TpmAlgId::Sha3_512 as u16,
}

impl TpmiAlgHash {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgHash {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "sha1")]
            value if value == Self::Sha1 as u16 => Self::Sha1,
            #[cfg(feature = "sha256")]
            value if value == Self::Sha256 as u16 => Self::Sha256,
            #[cfg(feature = "sha384")]
            value if value == Self::Sha384 as u16 => Self::Sha384,
            #[cfg(feature = "sha512")]
            value if value == Self::Sha512 as u16 => Self::Sha512,
            #[cfg(feature = "sm3_256")]
            value if value == Self::Sm3_256 as u16 => Self::Sm3_256,
            #[cfg(feature = "sha3_256")]
            value if value == Self::Sha3_256 as u16 => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            value if value == Self::Sha3_384 as u16 => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            value if value == Self::Sha3_512 as u16 => Self::Sha3_512,
            _ => {
                return Err(TpmErr::Rc(TpmRc::HASH));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Part 2 -- Structures, page 108, table 68, TPMI_ALG_SYM_OBJECT type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgSymObject {
    #[cfg(feature = "tdes")]
    Tdes = TpmAlgId::Tdes as u16,
    #[cfg(feature = "aes")]
    Aes = TpmAlgId::Aes as u16,
    #[cfg(feature = "sm4")]
    Sm4 = TpmAlgId::Sm4 as u16,
    #[cfg(feature = "camellia")]
    Camellia = TpmAlgId::Camellia as u16,
}

impl TpmiAlgSymObject {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgSymObject {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "tdes")]
            value if value == Self::Tdes as u16 => Self::Tdes,
            #[cfg(feature = "aes")]
            value if value == Self::Aes as u16 => Self::Aes,
            #[cfg(feature = "sm4")]
            value if value == Self::Sm4 as u16 => Self::Sm4,
            #[cfg(feature = "camellia")]
            value if value == Self::Camellia as u16 => Self::Camellia,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Part 2 -- Structures, page 110, table 75, TPMI_ALG_CIPHER_MODE type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgCipherMode {
    #[cfg(feature = "ctr")]
    Ctr = TpmAlgId::Ctr as u16,
    #[cfg(feature = "ofb")]
    Ofb = TpmAlgId::Ofb as u16,
    #[cfg(feature = "cbc")]
    Cbc = TpmAlgId::Cbc as u16,
    #[cfg(feature = "cfb")]
    Cfb = TpmAlgId::Cfb as u16,
    #[cfg(feature = "ecb")]
    Ecb = TpmAlgId::Ecb as u16,
}

impl TpmiAlgCipherMode {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }
}

impl convert::TryFrom<u16> for TpmiAlgCipherMode {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ctr")]
            value if value == Self::Ctr as u16 => Self::Ctr,
            #[cfg(feature = "ofb")]
            value if value == Self::Ofb as u16 => Self::Ofb,
            #[cfg(feature = "cbc")]
            value if value == Self::Cbc as u16 => Self::Cbc,
            #[cfg(feature = "cfb")]
            value if value == Self::Cfb as u16 => Self::Cfb,
            #[cfg(feature = "ecb")]
            value if value == Self::Ecb as u16 => Self::Ecb,
            _ => {
                return Err(TpmErr::Rc(TpmRc::MODE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Part 2 -- Structures, page 111, table 78, TPMU_HA union
pub struct TpmuHa {}

impl TpmuHa {
    pub const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        #[cfg(feature = "sha1")]
        {
            let sha1_size = 20u16;
            if sha1_size > size {
                size = sha1_size;
            }
        }

        #[cfg(feature = "sha256")]
        {
            let sha256_size = 32u16;
            if sha256_size > size {
                size = sha256_size;
            }
        }

        #[cfg(feature = "sha384")]
        {
            let sha384_size = 48u16;
            if sha384_size > size {
                size = sha384_size;
            }
        }

        #[cfg(feature = "sha512")]
        {
            let sha512_size = 64u16;
            if sha512_size > size {
                size = sha512_size;
            }
        }

        #[cfg(feature = "sm3_256")]
        {
            let sm3_256_size = 32u16;
            if sm3_256_size > size {
                size = sm3_256_size;
            }
        }

        #[cfg(feature = "sha3_256")]
        {
            let sha3_256_size = 32u16;
            if sha3_256_size > size {
                size = sha3_256_size;
            }
        }

        #[cfg(feature = "sha3_384")]
        {
            let sha3_384_size = 48u16;
            if sha3_384_size > size {
                size = sha3_384_size;
            }
        }

        #[cfg(feature = "sha3_512")]
        {
            let sha3_512_size = 64u16;
            if sha3_512_size > size {
                size = sha3_512_size;
            }
        }

        size
    }
}

// TCG TPM2 Library, Part 2 -- Structures, page 112, table 79, TPMT_HA structure (without conditional values)
#[derive(Debug, PartialEq)]
#[repr(C, u16)]
pub enum TpmtHa<'a> {
    #[cfg(feature = "sha1")]
    Sha1(TpmBuffer<'a>) = TpmAlgId::Sha1 as u16,
    #[cfg(feature = "sha256")]
    Sha256(TpmBuffer<'a>) = TpmAlgId::Sha256 as u16,
    #[cfg(feature = "sha384")]
    Sha384(TpmBuffer<'a>) = TpmAlgId::Sha384 as u16,
    #[cfg(feature = "sha512")]
    Sha512(TpmBuffer<'a>) = TpmAlgId::Sha512 as u16,
    #[cfg(feature = "sm3_256")]
    Sm3_256(TpmBuffer<'a>) = TpmAlgId::Sm3_256 as u16,
    #[cfg(feature = "sha3_256")]
    Sha3_256(TpmBuffer<'a>) = TpmAlgId::Sha3_256 as u16,
    #[cfg(feature = "sha3_384")]
    Sha3_384(TpmBuffer<'a>) = TpmAlgId::Sha3_384 as u16,
    #[cfg(feature = "sha3_512")]
    Sha3_512(TpmBuffer<'a>) = TpmAlgId::Sha3_512 as u16,
}

impl<'a> convert::From<&TpmtHa<'a>> for TpmiAlgHash {
    fn from(value: &TpmtHa<'a>) -> Self {
        match value {
            #[cfg(feature = "sha1")]
            TpmtHa::Sha1(_) => Self::Sha1,
            #[cfg(feature = "sha256")]
            TpmtHa::Sha256(_) => Self::Sha256,
            #[cfg(feature = "sha384")]
            TpmtHa::Sha384(_) => Self::Sha384,
            #[cfg(feature = "sha512")]
            TpmtHa::Sha512(_) => Self::Sha512,
            #[cfg(feature = "sm3_256")]
            TpmtHa::Sm3_256(_) => Self::Sm3_256,
            #[cfg(feature = "sha3_256")]
            TpmtHa::Sha3_256(_) => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            TpmtHa::Sha3_384(_) => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            TpmtHa::Sha3_512(_) => Self::Sha3_512,
        }
    }
}

// TCG TPM2 Library, Part 2 -- Structures, page 149, table 174, TPM2B_PUBLIC_KEY_RSA structure
#[cfg(feature = "rsa")]
#[derive(Debug, PartialEq)]
pub struct Tpm2bPublicKeyRsa<'a> {
    pub buffer: TpmBuffer<'a>,
}

// TCG TPM2 Library, Part 2 -- Structures, page 149, table 176, TPM2B_PRIVATE_KEY_RSA structure
#[cfg(feature = "rsa")]
#[derive(Debug, PartialEq)]
pub struct Tpm2bPrivateKeyRsa<'a> {
    pub buffer: TpmBuffer<'a>,
}

// TCG TPM2 Library, Part 2 -- Structures, page 150, table 177, TPM2B_ECC_PARAMETER structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bEccParameter<'a> {
    pub buffer: TpmBuffer<'a>,
}

// TCG TPM2 Library, Part 2 -- Structures, page 150, table 178, TPMS_ECC_POINT structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct TpmsEccPoint<'a> {
    pub x: Tpm2bEccParameter<'a>,
    pub y: Tpm2bEccParameter<'a>,
}
